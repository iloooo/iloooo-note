# java-基础

## Java核心

### Java字符集

- java采用unicode字符集，因此标识符也可以使用汉字声明，但是不建议使用。

### Java跨平台原理

- 语言跨平台是编译后的文件跨平台，而不是源程序跨平台
- javac编译成跨平台的.class的字节码文件，然后不同平台的JVM在将字节码解释成对应的机器码
- 一次编译，到处运行
- 中间码+虚拟机
- 编译为中间码的编译器与平台无关，编译生成的中间码也与平台无关（一次编译，到处运行），中间码再由解释器解释执行，解释器是与平台相关的，也就是不同的平台需要不同的解释器.

### 面向对象

- 封装 (Encapsulation)

	- 隐藏对象内部的复杂性，只对外公开简单的接口

- 继承 (Inheritance)

	- 子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，只是拥有。

- 多态 (Polymorphism)

	- 父类的引用指向子类的对象 或者 说把子类实例赋给父类引用

## 标识符和命名规范

### 标识符 Identifier

- 由26个英文字母大小写， 0-9

	- _或 $ 组成

- 数字不可以开头。
- 不可以使用关键字和保留字，但能包含关键字和保留字。
- Java中严格区分大小写，长度无限制。
- 标识符不能包含空格。

### 命名规范

- 包名：多单词组成时所有字母都小写： xxxyyyzzz
- 类名、接口名：多单词组成时，所有单词的首字母大写： XxxYyyZzz
- 变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写(驼峰)： xxxYyyZzz
- 常量名：所有字母都大写。多单词时每个单词用下划线连接： XXX_YYY_ZZZ

## 运算符

### 1-算法运算符

- + - + - * / % (前)++ (后)++ (前)-- (后)-- + 

	- ++

		- 运算的规则：

			- 1、对于自增变量本身来说，无论++在前还是在后，自增变量本身都会自增1
			- 2、但是对于自增表达式来说，++在前还是在后的结果是不同

				- a++

					- 这个表达式的值与a自增之前的值相同
					- 先赋值，再自增/减

				- ++a

					- 这个表达式的值与a自增之后的值相同
					- 先自增/减，再赋值

### 2-赋值运算符

- =

	- +=   -=   *=   /=   %=

		- 把左边的变量的值，与右边整个表达式的值相加，最后赋值给左边的变量
		- 如果左右两边的类型不一致，会隐含有类型转换

### 3-比较运算符

- ==   !=   >    <    >=   <=    instanceof
- ==和 equals 的区别

	- ==基本数据类型，比较的是值大小；引用数据类型比较的是地址
	- equals如果没有重写，相当于==；重写后一般比较内容

### 4-逻辑运算符

- &  &&   |   ||   !    ^

	- 逻辑与

		- &

			- true & true才为true，其他的都为false

	- 逻辑或

		- |

			- 左右两边有一个为true，结果就为true

	- 短路与

		- &&

			- 如果&&的左边的值为false，右边的就不看了，结果直接为false

	- 短路或

		- ||

			- 如果||的左边的值为true,右边的就不看了，结果直接为true

	- 逻辑非

		- !

			- !true为false ， !false为true

	- 逻辑异或

		- ^

			- 左右两边必须是一个为true,一个为false，结果采为true，否则为false

	- 注意：

		- 逻辑运算符的操作数，必须是布尔值

### 5-位运算符

- <<    >>    >>>   &    |    ^    ~

	- 左移

		- <<

			- 右边补0

	- 右移

		- >>

			- 左边补什么，看最高位，最高位是0，补0，最高位是1，补1

	- 无符号右移

		- >>>

			- 左边直接补0

	- 按位与

		- 1 & 1结果才为1，其他都是0

	- 按位或

		- 0 | 0结果采为0，否则都是1

	- 按位异或

		- 1 ^ 0 或 0 ^ 1是1,其他都是0

	- 位取反

		- ~1就是0，~0就是1

	- 注意：二进制的补码运算

### 6-三元运算符

- (条件表达式)? 表达式1 : 表达式2
- 执行特点：先判断条件，如果成立，结果为表达式1，否则 为表达式2

### ( ) >算术运算符 >比较运算符>逻辑运算符>三元运算符>赋值运算符

- 乘除高于加减

	- 难记，所以括号辅助

## 注释

### 1、单行注释

- //

### 2、多行注释

- /*                    */

	- 避免嵌套

### 3、文档注释

- /**                        */

	- 结合注解
	- 使用javadoc.exe

## 流程控制

### 顺序结构

### 分支结构

- if-else if - ... - else
- switch - case
- 嵌套分支结构

### 循环结构

- for(;;){ }
- while( ){ }
- do{ }while( )
- 嵌套循环结构

### 关键字：break、continue

## Java 关键字

## 数据类型

### 基本数据类型

- 整型

	- byte

		- 1个字节

			- 数据的范围：-128~127

	- short

		- 2个字节

			- 数据的范围：-32768~32767

	- int

		- 4个字节

	- long

		- 8个字节

			- 注意：在数字后面加L

- 字符型

	- char

		- 2个字节

			- 因为是2个字节，所以一个中文汉字，也可以表示一个字符  char c = '中';

		- Java中使用Unicode值来表示每一个字符

			- 至于这个Unicode值在底层怎么存，这个要和与具体的编码方式相结合

				- 编码方式有：GBK，UTF-8，ISO8859-1等

		- （2）字符还可以转义字符

			- 无法用一个字符表示的符号

				- 回车

					- \r

				- 换行

					- \n

				- 退格

					- \b

				- 制表位

					- \t

			- 在Java中有特殊意义的标点符号

				- 单引号

					- \'

				- 双引号

					- \"

				- 斜杠本身

					- \\

		- （3）字符的表示可以使用Unicode值

			- \u000a
			- 所以可以运算

- 浮点型

	- float

		- 4个字节

			- 小数的十进制科学计数法，大概小数点后6~7位

	- double

		- 8个字节

			- 小数的十进制科学计数法，大概小数点后15~16位

- 布尔型

	- boolean

		- 只有两个值true和false
		- 在编译之后都使用JVM中的int数据类型来代替： true用1表示， false用0表示

### 基本数据类型默认值

- 成员变量允许不显式赋初始值，有默认值
- 局部变量必须显式赋初始值

### 包装类

- 装箱

	- 基本数据类型-->包装类

		- 调用new Integer（100）方法

- 拆箱

	- 包装类-->基本数据类型

		- 调用包装类xxxValue（）方法

- 1.5后支持自动装箱拆箱
- 基本数据类型、包装类、String转换

	- 

### 引用数据类型

- 类
- 接口
- 数组

### 基本数据类型的转换

- 自动类型转换

	- 存储容量小的值或变量赋值给存储容量大的，或者存储容量小的与存储容量大的进行混合运算，出现存储容量小的会自动转成存储容量大的类型
	- byte,short,char --> int --> long -->float -->double 

		- 因为float和double类型的存储方式不一样，因此8个字节的long可以转成float而不会溢出
		- float和double 存储是分为：符号位，指数部分，尾数部分

- 强制类型转换

	- 需要使用强制类型转换符()
	- 强制类型转换有风险：溢出，损失精度

## 变量

### 成员变量

- 类变量（static修饰）
- 实例变量（不以static修饰）

### 局部变量

- 形参（方法、构造器中定义的变量）
- 方法局部变量（方法体内）
- 代码块局部变量（代码块内）

## 常量

### 在程序的整个运行过程中值保持不变的量

### final dataType variableName = value

### 静态常量、成员常量和局部常量

- // 静态常量
public static final double PI = 3.14;
// 声明成员常量
final int y = 10;
public static void main(String[] args) {
	// 声明局部常量
	final double x = 3.3;

